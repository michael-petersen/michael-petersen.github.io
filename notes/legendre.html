<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Legendre notes</title>
  <link rel="stylesheet" href="../css/main.css">
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML"></script>
</head>

<!--
TODO:
Add Legendre function discussion
Add notes about Legendre functions of the second kind
-->

<body class="home color-1">
  <div class="section" id="research">
    <div class="container">
      <div class="content">
        <div class="row">
	        <div class="title">
            <h4><a href="list.html">(back to notes list)</a></h4>
          </div>
          <div class="title">
            <h2>Legendre Recursion</h2>
            <br>
            <p>Legendre polynomials are some of the first polynomials one comes across. They are also critical for basis function expansion work owing to their role underpinning spherical harmonics! Therefore, an accurate evaluation is critical.</p>
            <br>
            <p><b>But first, some background. </b>Legendre polynomials \(P_k(u)\) satisfy the normalisation $$\int_{-1}^{1}du P_k(u)P_{k'}(u)= c_k \delta_{k k'}$$ where \(c_k = \frac{2}{2k+1}\). To perform <i>Gauss-Legendre integration</i>, we obtain an explicit set of nodes, \(\{u_i\}_{1\le i\le K_u}\), and weights, \(\{w_i\}_{1\le i\le K_u}\), such that one can perform an approximation of an integral \(G(u),~u\in[-1,1]\) as $$a_k = \frac{1}{c_k}\int_{-1}^{1}du G(u)P_k(u)$$ $$a_k = \frac{1}{c_k}\sum_{i=1}^{K_u}w_i G(u_i)P_k(u_i).$$ Sets of \(\{u_i\}, \{w_i\}\) are pre-tabulated in computing languages (they are high-accuracy solutions to the zeros of Legendre polynomials). The typical way to obtain values for \(P_k\) is through Bonnet's recursion formula, where $$P_k(\omega) = \frac{1}{k}\left[(2k-1)\omega P_{k-1}(\omega) - (k-1)P_{k-2}(\omega)\right],$$ with the seed values \(P_0(\omega)=1;~P_1(\omega)=\omega\).</p>
            <br>
            <p>The requirement of accurate evaluation also enables us to dip our toes in the world of highly optimised function evaluations. In this world, we are looking to (1) maximise accuracy, and (2) minimise the number of operations.</p>
            <br>
        	  <p>I've been interested in stable recursions for a bit now, and finally had the incentive to go through and write an improved Legendre recursion (that doesn't try to multiply a really big number by a really little number just to get close to unity). The full example can be found as a GitHub gist <a href="https://gist.github.com/michael-petersen/5943ec2d7697ea61c1c982a78ff661f4">here</a>, but I'll try to explain a bit better in this note.</p>
            <br>
            <p>This is a C++ code, but the ideas are generic. My general goal going forward is to write better recursions to minimise numerical errors -- this is a start!</p>
        	  <br>
            <pre><code>clang++ -I/opt/local/include/eigen3 -o legendre legendre_test.cpp</code></pre>
          </div>
	      </div>
     </div>
   </div>
 </div>


</body>
</html>
